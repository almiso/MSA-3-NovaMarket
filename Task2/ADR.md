### Название задачи: 
Проектирование механизма получения агрегированных данных об истории покупок для Frontend.

### Автор:
Александр Сосорев

### Дата:
3 марта 2026 г.

### Функциональные требования
Пользователь должен иметь возможность просматривать свою историю покупок.
Ниже представлены основные Use Cases:

| **№** | **Действующие лица или системы**              | **Use Case**                            | **Описание**                                                                                                                            |
|:-----:|:----------------------------------------------|:----------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------|
|   1   | Покупатель, API Gateway, OrderHistory Service | Просмотр списка заказов                 | Покупатель открывает раздел "История". Выводится список его заказов (стоимость, дата, способ доставки).                                 |
|   2   | Покупатель, API Gateway, OrderHistory Service | Просмотр деталей заказа                 | Покупатель открывает карточку заказа. Отображается список товаров (названия, цены, количества), чек, финальный статус, способ доставки. |
|   3   | Покупатель, API Gateway, OrderHistory Service | Скачивание чека / Повтор заказа / Отзыв | В карточке доступны действия (ссылка на PDF чека, кнопка рекавери корзины по товарам).                                                  |

### Нефункциональные требования
Архитектурно значимые нефункциональные требования:

| **№** | **Требование**                                                                                                                                                                |
|:-----:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|   1   | **Время отклика (Latency)**: Получение всей агрегированной информации по списку/деталям не должно превышать **0.3 секунды в 98% случаев**.                                    |
|   2   | **Масштабируемость (Scalability)**: Система должна поддерживать рост до 40 000+ заказов в день. Раздел истории будет посещаться часто, создавая Read-Heavy нагрузку.          |
|   3   | **Доступность (Availability)**: Если сервис Оплаты или Логистики временно недоступен или тормозит, просмотр "Истории заказов" у клиента всё равно должен продолжать работать. |

### Решение
Выбран паттерн: **CQRS (Command Query Responsibility Segregation)**.

**Архитектурное решение в рамках модели C4 (Контейнеры):**
- Мы физически разделяем чтение (Query) и запись (Command).
- **Command-сторона (OMS, Payment, Logistics)**: Выполняет тяжелую бизнес-логику (резерв, списания) и генерирует доменные события (`OrderCreated`, `PaymentSucceeded`, `DeliveryScheduled`) в Message Broker (Apache Kafka). Записывает данные в нормализованную транзакционную реляционную БД, в качестве которой выбран **PostgreSQL**, так как для финансовых транзакций (заказов) нам требуются строгие ACID гарантии.
- **Query-сторона (OrderHistory Service)**: Отдельный микросервис. Он реализует паттерн **Read Model Projection (Проекция модели чтения)**.
- В результате работы Проекции формируется **денормализованный JSON-документ**. Этот документ сохраняется в специализированную Document-ориентированную NoSQL БД. В качестве NoSQL БД выбрана **MongoDB**. 
  - *Почему именно NoSQL/MongoDB для истории?* Реляционная база (PostgreSQL) плоха для хранения заранее собранных агрегатов разной формы, к тому же со временем структура заказа может меняться. MongoDB позволяет хранить заказ клиента в виде готового JSON-дерева (со списком товаров, суммой, ссылкой на чек внутри одного документа). В нём собраны вместе id товаров, цены на момент покупки, ссылка на файл чека и итоговый статус доставки.
- При запросе с фронтенда на `GET /api/history` API Gateway роутит запрос сразу в `OrderHistory Service`. Тот делает одиночный простой поиск (например, `db.orders.find({ userId: 123 })`) в **MongoDB** и мгновенно возвращает готовый огромный кусок данных без вычислений и JOIN-ов.

**Логика выбора**:
Требование 0.3 сек на ответ и высокая доступность делают синхронные запросы (API Composition) невозможными. CQRS позволяет перенести тяжесть агрегации данных на момент их записи/поступления в фоне (когда происходит событие/event), а при чтении просто отдавать "предварительно склеенный слепок", обеспечивая мгновенный отклик (O(1) по времени поиска в БД). 

*(Контейнерная C2-диаграмма, иллюстрирующая внедрение CQRS, находится в файле `C2_CQRS_diagram.puml` в папке `Task2`)*.

### Альтернативы

1. **API Composition (Синхронная агрегация на лету)**
   - *Описание:* API Gateway (или отдельный Backend-For-Frontend агрегатор) получает запрос клиента и синхронно отправляет HTTP/gRPC запросы веером во все сервисы: `OMS` -> `Catalog` (получить названия товаров) -> `Payment` (получить чек) -> `Logistics` (получить метод доставки). Затем склеивает это в памяти и отвечает клиенту.
   - *Плюсы:* Самая простая реализация. Отсутствует задержка обновления (Strong Consistency).
   - *Минусы:* Нарушает НФТ по 0.3 сек отклика (сетевые задержки 4-х синхронных походов складываются). Возникает паттерн «Распределенный монолит». Зависимость от доступности (упал Catalog - упала и История заказов для клиента).

2. **Event Sourcing**
   - *Описание:* Данные в БД не перезаписываются, а хранятся исключительно как Append-Only лог событий (Event Store). Состояние заказа для клиента высчитывается на лету путем проигрывания всех событий заказа с момента его создания («сборка в реальности»).
   - *Плюсы:* Идеальный аудит. Можно воспроизвести состояние системы на любой момент времени в прошлом.
   - *Минусы:* Не обоснованная для MVP колоссальная сложность разработки и поддержки. Медленное чтение при большом количестве событий без применения снимков (Snapshots).

**Недостатки, ограничения, риски выбранного решения (CQRS):**

- **Eventual Consistency (Согласованность в конечном счете)**: Данные в `History DB` обновляются асинхронно через брокер. Возможна ситуация (риск), что клиент оплатил заказ, его тут же перебросило на страницу "История", а `OrderHistory Service` еще не успел прочитать событие об оплате из Kafka (задержка 50-100 мс). Пользователь увидит старый статус "Ожидает оплаты" и занервничает.
- **Дублирование данных**: Мы храним суть заказа как минимум дважды (в нормализованном виде в OMS DB и в денормализованном в History DB), что увеличивает расходы на хранилища.
- **Сложность инфраструктуры**: Требуется поддерживать еще один тип БД (NoSQL для History), механизмы DLQ (Dead Letter Queue) для Kafka на случай сбоев консьютинга при проекции модели.
